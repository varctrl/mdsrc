---
title: 原码,反码,补码
date: 2017-10-03 
tags: [bin] 
---

### 1.位(bit),字节(byte)

位是计算机中最基本的存储单元 ,以二进制表示,即0,1两个数,每8位为一字节(byte),字节是存储资料的基本单元
<!--more-->
---
### 2.真值,机器值

机器数就是二进制数在计算机中内部的表现形式,计算机内部用一个数的最高位表示符号,正数为0, 负数为1.剩下7位表示数,由于最高位表示符号,所以有些情况下不等于这个数真正数值(真值)

例如:

机器数1111 1111的十进制数是-127,二进制数1111 1111的十进制数是255,这种情况下不一样 机器数0111 1111的十进制数是+127（注:”+”可省略）,二进制数0111 1111的十进制数是127，这种情况下一样



| 二进制数      | 机器数     |  十进制数    |
| --------   | -----:  | :----: |
|  1111 1111 |   -127  | 255    |
|  0111 1111 |   +127  | 127    |
### 3.原码,反码,补码

原码, 反码, 补码是机器存储一个具体数字的三种编码方式,计算机内部采用补码方式（注:但它可以用三种编码方式表示一个数）

* 原码：就是机器数,表示范围 [1111 1111 , 0111 1111],即 十进制数 [-127 , 127]

* 反码 :正数的反码是其本身(原码)，负数的反码是在其原码的基础上, 符号位不变,其余位取反,比如十进制9的反码为0000 1001,十进制-9的反码是1111 0110（注：先转换成原码再计算）

* 补码：正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余位取反, 最后加上1（相当于反码再加上1）,比如十进制9的补码为0000 1001,十进制-9的补码是1111 0111

### 4.计算机内部采用补码的原因
为了避免基础电路更加复杂,简化运算流程, 众所周知,减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 又由于机器数最高位是符号,所以机器可以只有加法而没有减法, 这样计算机运算就更简单比如十进制中1-1=1+（-1）=0，采用原码的编码方式计算负数错误，采用反码的编码方式会出现两个0，（+0,-0），而采用补码的编码方式没有错误,又能比反码多表示一个数（注:补码将反码中的—0正确的表示成了-128）
